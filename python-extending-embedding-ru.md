# Расширение и встраивание интерпретатора Python
Этот документ описывает, как писать модули на C или C++ для расширения интерпретатора Python новыми модулями. Эти модули могут не только определять новые функции, но и создавать новые типы объектов и их методы. Документ также объясняет, как встроить интерпретатор Python в другое приложение, чтобы использовать его в качестве языка расширения. Наконец, в нём описано, как компилировать и связывать модули расширения, чтобы они могли загружаться динамически (во время выполнения) в интерпретатор, если эта возможность поддерживается операционной системой.

Этот документ предполагает базовые знания Python. Для неформального знакомства с языком см. [The Python Tutorial](https://docs.python.org/3/tutorial/index.html#tutorial-index). Справочник по языку Python [The Python Language Reference](https://docs.python.org/3/reference/index.html#reference-index) даёт более формальное определение языка. Стандартная библиотека Python [The Python Standard Library](https://docs.python.org/3/library/index.html#library-index) содержит документацию по существующим типам объектов, функциям и модулям (как встроенным, так и написанным на Python), которые делают язык универсальным.

Для детального описания всего API Python/C см. [Python/C API Reference Manual](https://docs.python.org/3/c-api/index.html#c-api-index).

## Рекомендуемые сторонние инструменты
Этот справочник описывает только основные инструменты для создания расширений, которые предоставляются в данной версии CPython. Сторонние инструменты, такие как [Cython](https://cython.org/), [cffi](https://cffi.readthedocs.io/en/stable/), [SWIG](https://www.swig.org/) и [Numba](https://numba.pydata.org/), предлагают как более простые, так и более сложные подходы к созданию расширений на C и C++ для Python.

## Создание расширений без сторонних инструментов
Этот раздел справочника посвящён созданию расширений на C и C++ без использования сторонних инструментов. Он предназначен в первую очередь для разработчиков таких инструментов, а не как рекомендуемый способ создания собственных расширений на C.
  
- [Расширение и встраивание интерпретатора Python](#расширение-и-встраивание-интерпретатора-python)
  - [Рекомендуемые сторонние инструменты](#рекомендуемые-сторонние-инструменты)
  - [Создание расширений без сторонних инструментов](#создание-расширений-без-сторонних-инструментов)
- [1. Расширение Python с помощью C или C++](#1-расширение-python-с-помощью-c-или-c)
  - [1.1 Простой пример](#11-простой-пример)
  - [1.2. Интермеццо: ошибки и исключения](#12-интермеццо-ошибки-и-исключения)
  - [1.3. Возвращение к примеру](#13-возвращение-к-примеру)
  - [1.4. Таблица методов модуля и функция инициализации](#14-таблица-методов-модуля-и-функция-инициализации)
  - [1.5. Компиляция и компоновка](#15-компиляция-и-компоновка)
  - [1.6. Вызов функций Python из C](#16-вызов-функций-python-из-c)
  - [1.7. Извлечение параметров в функциях расширения](#17-извлечение-параметров-в-функциях-расширения)
  - [1.8. Ключевые параметры для функций расширения](#18-ключевые-параметры-для-функций-расширения)
  - [1.9. Создание произвольных значений](#19-создание-произвольных-значений)
  - [1.10. Учёт ссылок (Reference Counts)](#110-учёт-ссылок-reference-counts)
  - [1.11. Написание расширений на C++](#111-написание-расширений-на-c)
  - [1.12. Предоставление C API для модуля расширения](#112-предоставление-c-api-для-модуля-расширения)
- [2. Определение типов расширений: учебное пособие](#2-определение-типов-расширений-учебное-пособие)
  - [2.1. Основы](#21-основы)
  - [2.2. Добавление данных и методов к базовому примеру](#22-добавление-данных-и-методов-к-базовому-примеру)
  - [2.3. Более точный контроль над атрибутами данных](#23-более-точный-контроль-над-атрибутами-данных)
  - [2.4. Поддержка циклического сборщика мусора](#24-поддержка-циклического-сборщика-мусора)
  - [2.5. Наследование от других типов](#25-наследование-от-других-типов)
- [3. Определение типов расширений: различные темы](#3-определение-типов-расширений-различные-темы)
  - [3.1. Завершение и освобождение памяти](#31-завершение-и-освобождение-памяти)
  - [3.2. Представление объекта](#32-представление-объекта)
  - [3.3. Управление атрибутами](#33-управление-атрибутами)
  - [3.4. Сравнение объектов](#34-сравнение-объектов)
  - [3.5. Поддержка абстрактных протоколов](#35-поддержка-абстрактных-протоколов)
  - [3.6. Поддержка слабых ссылок](#36-поддержка-слабых-ссылок)
  - [3.7. Дополнительные рекомендации](#37-дополнительные-рекомендации)
- [4. Сборка расширений на C и C++](#4-сборка-расширений-на-c-и-c)
  - [4.1. Сборка расширений на C и C++ с помощью setuptools](#41-сборка-расширений-на-c-и-c-с-помощью-setuptools)
- [5. Сборка расширений на C и C++ в Windows](#5-сборка-расширений-на-c-и-c-в-windows)
  - [5.1. Пошаговое руководство](#51-пошаговое-руководство)
  - [5.2. Различия между Unix и Windows](#52-различия-между-unix-и-windows)
  - [5.3. Использование DLL на практике](#53-использование-dll-на-практике)
  - [Встраивание среды выполнения CPython в более крупное приложение](#встраивание-среды-выполнения-cpython-в-более-крупное-приложение)
- [1. Встраивание Python в другое приложение](#1-встраивание-python-в-другое-приложение)
  - [1.1. Встраивание на очень высоком уровне](#11-встраивание-на-очень-высоком-уровне)
  - [1.2. За пределами встраивания на очень высоком уровне: обзор](#12-за-пределами-встраивания-на-очень-высоком-уровне-обзор)
  - [1.3. Чистое встраивание](#13-чистое-встраивание)
  - [1.4. Расширение встроенного Python](#14-расширение-встроенного-python)
  - [1.5. Встраивание Python в C++](#15-встраивание-python-в-c)
  - [1.6. Компиляция и компоновка в Unix-подобных системах](#16-компиляция-и-компоновка-в-unix-подобных-системах)

# 1. Расширение Python с помощью C или C++
Добавление новых встроенных модулей в Python довольно просто, если вы умеете программировать на C. Такие расширения могут делать две вещи, которые невозможно реализовать напрямую в Python: создавать новые встроенные типы объектов и вызывать функции библиотек C и системные вызовы.

Для поддержки расширений API Python (Application Programmers Interface) предоставляет набор функций, макросов и переменных, которые обеспечивают доступ к большинству аспектов среды выполнения Python. API Python подключается в исходном коде C с помощью заголовочного файла `"Python.h"`.

Компиляция модуля расширения зависит от его назначения, а также от конфигурации вашей системы; подробности об этом приведены в следующих главах.

> **Примечание**: Интерфейс расширений на C специфичен для CPython, и модули расширений не работают в других реализациях Python. Во многих случаях можно обойтись без написания расширений на C и сохранить переносимость на другие реализации. Например, если ваша задача заключается в вызове функций из C-библиотек или системных вызовов, вам следует рассмотреть возможность использования модуля [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes) или библиотеки [cffi](https://cffi.readthedocs.io/en/stable/) вместо написания собственного кода на C. Эти модули позволяют писать Python-код для взаимодействия с C-кодом и обладают большей переносимостью между реализациями Python, чем написание и компиляция модуля расширения на C.

## 1.1 Простой пример
Давайте создадим модуль расширения с именем `spam` и предположим, что мы хотим создать интерфейс Python для функции из C-библиотеки <span style="font-family: Consolas, sans-serif;">system()</span> [[1]](#footnote-1)<a id="footnote-1-back"></a>. Эта функция принимает строку, заканчивающуюся нулевым символом, в качестве аргумента и возвращает целое число. Мы хотим, чтобы эту функцию можно было вызвать из Python следующим образом:

```python
import spam
status = spam.system("ls -l")
```

Начнём с создания файла `spammodule.c.` (Исторически, если модуль называется `spam`, файл C, содержащий его реализацию, называется `spammodule.c`; если имя модуля очень длинное, например `spammify`, то файл может быть просто `spammify.c.`)

Первые две строки нашего файла могут быть следующими:

```c
#define PY_SSIZE_T_CLEAN
#include <Python.h>
```

которые подключают API Python (вы можете добавить комментарий, описывающий назначение модуля, и уведомление о авторских правах, если хотите).

> **Примечание**: Поскольку Python может определять некоторые макросы препроцессора, которые влияют на стандартные заголовочные файлы на некоторых системах, необходимо включать `Python.h` до любых стандартных заголовочных<br><br>`#define PY_SSIZE_T_CLEAN` использовался для указания, что в некоторых API должен использоваться тип `Py_ssize_t` вместо `int`. Это больше не обязательно с Python 3.13, но мы оставляем его для обеспечения обратной совместимости. См. раздел [Strings and buffers](https://docs.python.org/3.13/c-api/arg.html#arg-parsing-string-and-buffers) для описания этого макроса.

Все символы, видимые пользователю и определённые в `Python.h`, имеют префикс `Py` или `PY`, за исключением тех, что определены в стандартных заголовочных файлах. Для удобства и поскольку они активно используются интерпретатором Python, файл `"Python.h"` включает несколько стандартных заголовочных файлов: `<stdio.h>`, `<string.h>`, `<errno.h>` и `<stdlib.h>`. Если последний заголовочный файл отсутствует в вашей системе, он напрямую объявляет функции <span style="font-family: Consolas, sans-serif;">malloc()</span>, <span style="font-family: Consolas, sans-serif;">free()</span> и <span style="font-family: Consolas, sans-serif;">realloc()</span>.

Следующим шагом, который мы добавляем в файл модуля, является функция на C, которая будет вызываться, когда будет оцениваться выражение Python `spam.system(string)` (мы вскоре увидим, как она будет вызываться):

```c
static PyObject *
spam_system(PyObject *self, PyObject *args)
{
    const char *command;
    int sts;

    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;
    sts = system(command);
    return PyLong_FromLong(sts);
}
```

В Python аргументы, передаваемые функции, можно легко перевести в список аргументов C-функции (например, одно выражение `"ls -l"`). C-функция всегда имеет два аргумента, традиционно называемые *self* и *args*.

Аргумент *self* указывает на объект модуля для функций на уровне модуля; для метода он будет указывать на экземпляр объекта.

Аргумент *args* будет указателем на объект кортежа Python, содержащий аргументы. Каждый элемент этого кортежа соответствует одному аргументу из списка аргументов вызова. Аргументы — это объекты Python, и чтобы работать с ними в нашей C-функции, необходимо преобразовать их в значения C. Функция [PyArg_ParseTuple()](https://docs.python.org/3.13/c-api/arg.html#c.PyArg_ParseTuple) из API Python проверяет типы аргументов и преобразует их в значения C. Она использует строку-шаблон для определения требуемых типов аргументов, а также типов C-переменных, в которые будут сохранены преобразованные значения. Подробнее об этом будет сказано позже.

[PyArg_ParseTuple()](https://docs.python.org/3.13/c-api/arg.html#c.PyArg_ParseTuple) возвращает **true** (не ноль), если все аргументы имеют правильный тип, и их компоненты были сохранены в переменных, адреса которых были переданы в функцию. Если передан некорректный список аргументов, функция возвращает **false** (ноль). В этом случае она также вызывает соответствующее исключение, чтобы вызывающая функция могла сразу вернуть `NULL` (как мы видели в примере).

## 1.2. Интермеццо: ошибки и исключения
Текст для подраздела 1.1.

## 1.3. Возвращение к примеру
Текст для подраздела 1.1.

## 1.4. Таблица методов модуля и функция инициализации
Текст для подраздела 1.1.

## 1.5. Компиляция и компоновка
Текст для подраздела 1.1.

## 1.6. Вызов функций Python из C
Текст для подраздела 1.1.

## 1.7. Извлечение параметров в функциях расширения
Текст для подраздела 1.1.

## 1.8. Ключевые параметры для функций расширения
Текст для подраздела 1.1.

## 1.9. Создание произвольных значений
Текст для подраздела 1.1.

## 1.10. Учёт ссылок (Reference Counts)
Текст для подраздела 1.1.

## 1.11. Написание расширений на C++
Текст для подраздела 1.1.

## 1.12. Предоставление C API для модуля расширения
Текст для подраздела 1.1.

# 2. Определение типов расширений: учебное пособие
Текст для раздела 1.

## 2.1. Основы
Текст для подраздела 1.1.

## 2.2. Добавление данных и методов к базовому примеру
Текст для подраздела 1.1.

## 2.3. Более точный контроль над атрибутами данных
Текст для подраздела 1.1.

## 2.4. Поддержка циклического сборщика мусора
Текст для подраздела 1.1.

## 2.5. Наследование от других типов
Текст для подраздела 1.1.

# 3. Определение типов расширений: различные темы
Текст для раздела 1.

## 3.1. Завершение и освобождение памяти
Текст для подраздела 1.1.

## 3.2. Представление объекта
Текст для подраздела 1.1.

## 3.3. Управление атрибутами
Текст для подраздела 1.1.

## 3.4. Сравнение объектов
Текст для подраздела 1.1.

## 3.5. Поддержка абстрактных протоколов
Текст для подраздела 1.1.

## 3.6. Поддержка слабых ссылок
Текст для подраздела 1.1.

## 3.7. Дополнительные рекомендации
Текст для подраздела 1.1.

# 4. Сборка расширений на C и C++
Текст для раздела 1.

## 4.1. Сборка расширений на C и C++ с помощью setuptools
Текст для подраздела 1.1.

# 5. Сборка расширений на C и C++ в Windows
Текст для раздела 1.

## 5.1. Пошаговое руководство
Текст для раздела 1.

## 5.2. Различия между Unix и Windows
Текст для раздела 1.

## 5.3. Использование DLL на практике
Текст для раздела 1.

## Встраивание среды выполнения CPython в более крупное приложение
Иногда вместо создания расширения, которое выполняется внутри интерпретатора Python как основное приложение, бывает полезно встроить среду выполнения CPython в более крупное приложение. В этом разделе рассматриваются основные аспекты успешной интеграции CPython в такие приложения.

# 1. Встраивание Python в другое приложение

## 1.1. Встраивание на очень высоком уровне
Текст для подраздела 1.1.

## 1.2. За пределами встраивания на очень высоком уровне: обзор
Текст для подраздела 1.1.

## 1.3. Чистое встраивание
Текст для подраздела 1.1.

## 1.4. Расширение встроенного Python
Текст для подраздела 1.1.

## 1.5. Встраивание Python в C++
Текст для подраздела 1.1.

## 1.6. Компиляция и компоновка в Unix-подобных системах
Текст для подраздела 1.1.

**Сноски**

<a id="footnote-1"></a>[[1](#footnote-1-back)] Интерфейс для этой функции уже существует в стандартном модуле [os](https://docs.python.org/3/library/os.html#module-os) — он был выбран в качестве простого и наглядного примера.
# Расширение и встраивание интерпретатора Python
Этот документ описывает, как писать модули на C или C++ для расширения интерпретатора Python новыми модулями. Эти модули могут не только определять новые функции, но и создавать новые типы объектов и их методы. Документ также объясняет, как встроить интерпретатор Python в другое приложение, чтобы использовать его в качестве языка расширения. Наконец, в нём описано, как компилировать и связывать модули расширения, чтобы они могли загружаться динамически (во время выполнения) в интерпретатор, если эта возможность поддерживается операционной системой.

Этот документ предполагает наличие базовых знаний языка Python. Для неформального знакомства с языком см. [The Python Tutorial](https://docs.python.org/3/tutorial/index.html#tutorial-index). [The Python Language Reference](https://docs.python.org/3/reference/index.html#reference-index) даёт более формальное определение языка. Стандартная библиотека Python [The Python Standard Library](https://docs.python.org/3/library/index.html#library-index) содержит документацию по существующим типам объектов, функциям и модулям (как встроенным, так и написанным на Python), которые делают язык универсальным.

Для детального описания всего API Python/C см. [Python/C API Reference Manual](https://docs.python.org/3/c-api/index.html#c-api-index).

## Рекомендуемые сторонние инструменты
Этот справочник описывает только основные инструменты для создания расширений, которые предоставляются в данной версии CPython. Сторонние инструменты, такие как [Cython](https://cython.org/), [cffi](https://cffi.readthedocs.io/en/stable/), [SWIG](https://www.swig.org/) и [Numba](https://numba.pydata.org/), предлагают как более простые, так и более сложные подходы к созданию расширений на C и C++ для Python.

## Создание расширений без сторонних инструментов
Этот раздел справочника посвящён созданию расширений на C и C++ без использования сторонних инструментов. Он предназначен в первую очередь для разработчиков таких инструментов, а не как рекомендуемый способ создания собственных расширений на C.
  
- [Расширение и встраивание интерпретатора Python](#расширение-и-встраивание-интерпретатора-python)
  - [Рекомендуемые сторонние инструменты](#рекомендуемые-сторонние-инструменты)
  - [Создание расширений без сторонних инструментов](#создание-расширений-без-сторонних-инструментов)
- [1. Расширение Python с помощью C или C++](#1-расширение-python-с-помощью-c-или-c)
  - [1.1 Простой пример](#11-простой-пример)
  - [1.2. Интермеццо: ошибки и исключения](#12-интермеццо-ошибки-и-исключения)
  - [1.3. Возвращение к примеру](#13-возвращение-к-примеру)
  - [1.4. Таблица методов модуля и функция инициализации](#14-таблица-методов-модуля-и-функция-инициализации)
  - [1.5. Компиляция и компоновка](#15-компиляция-и-компоновка)
  - [1.6. Вызов функций Python из C](#16-вызов-функций-python-из-c)
  - [1.7. Извлечение параметров в функциях расширения](#17-извлечение-параметров-в-функциях-расширения)
  - [1.8. Ключевые параметры для функций расширения](#18-ключевые-параметры-для-функций-расширения)
  - [1.9. Создание произвольных значений](#19-создание-произвольных-значений)
  - [1.10. Учёт ссылок (Reference Counts)](#110-учёт-ссылок-reference-counts)
  - [1.11. Написание расширений на C++](#111-написание-расширений-на-c)
  - [1.12. Предоставление C API для модуля расширения](#112-предоставление-c-api-для-модуля-расширения)
- [2. Определение типов расширений: учебное пособие](#2-определение-типов-расширений-учебное-пособие)
  - [2.1. Основы](#21-основы)
  - [2.2. Добавление данных и методов к базовому примеру](#22-добавление-данных-и-методов-к-базовому-примеру)
  - [2.3. Более точный контроль над атрибутами данных](#23-более-точный-контроль-над-атрибутами-данных)
  - [2.4. Поддержка циклического сборщика мусора](#24-поддержка-циклического-сборщика-мусора)
  - [2.5. Наследование от других типов](#25-наследование-от-других-типов)
- [3. Определение типов расширений: различные темы](#3-определение-типов-расширений-различные-темы)
  - [3.1. Завершение и освобождение памяти](#31-завершение-и-освобождение-памяти)
  - [3.2. Представление объекта](#32-представление-объекта)
  - [3.3. Управление атрибутами](#33-управление-атрибутами)
  - [3.4. Сравнение объектов](#34-сравнение-объектов)
  - [3.5. Поддержка абстрактных протоколов](#35-поддержка-абстрактных-протоколов)
  - [3.6. Поддержка слабых ссылок](#36-поддержка-слабых-ссылок)
  - [3.7. Дополнительные рекомендации](#37-дополнительные-рекомендации)
- [4. Сборка расширений на C и C++](#4-сборка-расширений-на-c-и-c)
  - [4.1. Сборка расширений на C и C++ с помощью setuptools](#41-сборка-расширений-на-c-и-c-с-помощью-setuptools)
- [5. Сборка расширений на C и C++ в Windows](#5-сборка-расширений-на-c-и-c-в-windows)
  - [5.1. Пошаговое руководство](#51-пошаговое-руководство)
  - [5.2. Различия между Unix и Windows](#52-различия-между-unix-и-windows)
  - [5.3. Использование DLL на практике](#53-использование-dll-на-практике)
  - [Встраивание среды выполнения CPython в более крупное приложение](#встраивание-среды-выполнения-cpython-в-более-крупное-приложение)
- [1. Встраивание Python в другое приложение](#1-встраивание-python-в-другое-приложение)
  - [1.1. Встраивание на очень высоком уровне](#11-встраивание-на-очень-высоком-уровне)
  - [1.2. За пределами встраивания на очень высоком уровне: обзор](#12-за-пределами-встраивания-на-очень-высоком-уровне-обзор)
  - [1.3. Чистое встраивание](#13-чистое-встраивание)
  - [1.4. Расширение встроенного Python](#14-расширение-встроенного-python)
  - [1.5. Встраивание Python в C++](#15-встраивание-python-в-c)
  - [1.6. Компиляция и компоновка в Unix-подобных системах](#16-компиляция-и-компоновка-в-unix-подобных-системах)

# 1. Расширение Python с помощью C или C++
Довольно легко можно добавить новые встроенные модули в Python, если вы умеете программировать на C. Такие *расширения* могут делать две вещи, которые невозможно реализовать напрямую в Python: создавать новые встроенные типы объектов и вызывать функции библиотек C и системные вызовы.

Для того, чтобы поддерживать расширения Python API (Application Programmers Interface) предоставляет набор функций, макросов и переменных, которые обеспечивают доступ к большинству аспектов среды выполнения Python. Python API подключается в исходном коде C с помощью заголовочного файла `"Python.h"`.

Компиляция модуля расширения зависит от его назначения, а также от конфигурации вашей системы; подробности об этом приведены в следующих главах.

> **Примечание**: Интерфейс расширений на C специфичен для CPython, и модули расширений не работают в других реализациях Python. В большинстве случаев можно обойтись без написания расширений на C и сохранить переносимость на другие реализации. Например, если ваша задача заключается в вызове функций из C-библиотек или системных вызовов, вам следует рассмотреть возможность использования модуля [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes) или библиотеки [cffi](https://cffi.readthedocs.io/en/stable/) вместо написания собственного кода на C. Эти модули позволяют писать Python-код для взаимодействия с C-кодом и обладают большей переносимостью между реализациями Python, чем написание и компиляция модуля расширения на C.

## 1.1 Простой пример
Давайте создадим модуль расширения с именем `spam` и предположим, что мы хотим создать Python интерфейс для функции <span style="font-family: Consolas, sans-serif;">system()</span> [[1]](#footnote-1)<a id="footnote-1-back"></a> из C-библиотеки. Эта функция принимает строку, заканчивающуюся нулевым символом, в качестве аргумента и возвращает целое число. Мы хотим, чтобы эту функцию можно было вызвать из Python следующим образом:

```python
import spam
status = spam.system("ls -l")
```

Начнём с создания файла `spammodule.c.` (Исторически, если модуль называется `spam`, файл C, содержащий его реализацию, называется `spammodule.c`; если имя модуля очень длинное, например `spammify`, то файл может быть просто `spammify.c.`)

Первые две строки нашего файла могут быть следующими:

```c
#define PY_SSIZE_T_CLEAN
#include <Python.h>
```

Эти строки подключают Python API (вы можете добавить комментарий, описывающий назначение модуля, и уведомление о авторских правах, если хотите).

> **Примечание**: Поскольку Python может определять некоторые макросы препроцессора, которые влияют на стандартные заголовочные файлы на некоторых системах, необходимо включать `Python.h` до любых стандартных заголовочных<br><br>`#define PY_SSIZE_T_CLEAN` был использован для указания, что в некоторых API должен использоваться тип `Py_ssize_t` вместо `int`. Это больше не обязательно с версии Python 3.13, но мы оставим это для обеспечения обратной совместимости. См. раздел [Strings and buffers](https://docs.python.org/3.13/c-api/arg.html#arg-parsing-string-and-buffers) для описания этого макроса.

Все символы, видимые пользователю, определённые `Python.h`, имеют префикс `Py` или `PY`, за исключением тех, что определены в стандартных заголовочных файлах. Для удобства `"Python.h"` включает несколько стандартных заголовочных файлов: `<stdio.h>`, `<string.h>`, `<errno.h>` и `<stdlib.h>`,поскольку они активно используются интерпретатором Python. Если последний заголовочный файл отсутствует в вашей системе, он напрямую объявляет функции <span style="font-family: Consolas, sans-serif;">malloc()</span>, <span style="font-family: Consolas, sans-serif;">free()</span> и <span style="font-family: Consolas, sans-serif;">realloc()</span>.

Следующее, что мы добавим в файл нашего модуля будет функция на C, которая будет вызываться, когда выражение на Python `spam.system(string)` будет вычисляться (мы вскоре увидим, как она будет вызываться):

```c
static PyObject *
spam_system(PyObject *self, PyObject *args)
{
    const char *command;
    int sts;

    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;
    sts = system(command);
    return PyLong_FromLong(sts);
}
```

Существует прямой перевод из списка аргументов в Python (например, единственного выражения `"ls -l"`) в аргументы, передаваемые в функцию C. Функция на С всегда имеет два аргумента, которые принято называть *self* и *args*.

Аргумент *self* указывает на объект модуля для функций на уровне модуля; для метода он будет указывать на экземпляр объекта.

Аргумент *args* будет указателем на объект кортежа Python, содержащий аргументы. Каждый элемент этого кортежа соответствует одному аргументу из списка аргументов вызова. Аргументы — это объекты Python, и чтобы работать с ними в нашей функции на языке С, необходимо преобразовать их в значения C. Функция [PyArg_ParseTuple()](https://docs.python.org/3.13/c-api/arg.html#c.PyArg_ParseTuple) из API Python проверяет типы аргументов и преобразует их в значения C. Она использует строку-шаблон для определения требуемых типов аргументов, а также типов C-переменных, в которые будут сохранены преобразованные значения. Подробнее об этом будет сказано позже.

[PyArg_ParseTuple()](https://docs.python.org/3.13/c-api/arg.html#c.PyArg_ParseTuple) возвращает **true** (не ноль), если все аргументы имеют правильный тип, и их компоненты были сохранены в переменных, адреса которых были переданы в функцию. Если передан некорректный список аргументов, функция возвращает **false** (ноль). В этом случае она также вызывает соответствующее исключение, чтобы вызывающая функция могла сразу вернуть `NULL` (как мы видели в примере).

## 1.2. Интермеццо: ошибки и исключения
Важная договорённость, которая применяется во всей интерпретаторе Python, заключается в следующем: когда функция завершает выполнение с ошибкой, она должна установить условие исключения и вернуть значение ошибки (обычно `-1` или указатель `NULL`). Информация об исключении сохраняется в трёх полях состояния потока интерпретатора. Эти поля равны `NULL`, если исключения нет. В противном случае они являются C-эквивалентами полей кортежа Python, возвращаемого функцией [sys.exc_info()](https://docs.python.org/3/library/sys.html#sys.exc_info). Это тип исключения, экземпляр исключения и объект трассировки стека. Важно знать о них, чтобы понять, как ошибки передаются между различными частями программы.

Python API определяет ряд функций для установки различных типов исключений.

Самая распространённая функция — это [PyErr_SetString()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetString). Её аргументами являются объект исключения и строка в C-строка. Объект исключения обычно является заранее определённым объектом, таким как <span style="font-family: Consolas, sans-serif;">PyExc_ZeroDivisionError</span>. C-Строка указывает на причину ошибки и преобразуется в объект строки Python, который сохраняется как «сопутствующее значение» исключения.

Ещё одна полезная функция — [PyErr_SetFromErrno()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetFromErrno), которая принимает только аргумент исключения и строит сопутствующее значение, используя глобальную переменную <span style="font-family: Consolas, sans-serif;">errno</span>. Самая универсальная функция — это [PyErr_SetObject()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetObject), которая принимает два объекта в качестве аргументов: исключение и его сопутствующее значение. Вам не нужно вызывать [Py_INCREF()](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF) для объектов, передаваемых в эти функции.

Вы можете безопасно проверить, было ли установлено исключение, с помощью [PyErr_Occurred()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Occurred). Эта функция возвращает текущий объект исключения или `NULL`, если исключение не произошло. Обычно нет необходимости вызывать [PyErr_Occurred()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Occurred), чтобы проверить, произошло ли исключение в результате вызова функции, так как это можно понять по возвращаемому значению.

Когда функция *f*, вызывающая другую функцию *g*, обнаруживает, что последняя завершилась с ошибкой, *f* сама должна вернуть значение ошибки (обычно `NULL` или `-1`). Ей не следует вызывать одну из функций `PyErr_*` — одна из них уже была вызвана функцией *g*. Затем функция *f* должна вернуть индикатор ошибки своей функции, которая её вызвала, опять же без вызова `PyErr_*`, и так далее — наиболее подробная причина ошибки уже была сообщена функцией, которая её впервые обнаружила. Как только ошибка достигает главного цикла интерпретатора Python, выполнение текущего Python-кода прерывается и начинается поиск обработчика исключения, указанного программистом Python.

(Существуют ситуации, когда модуль может предоставить более детализированное сообщение об ошибке, вызвав другую функцию `PyErr_*`, и в таких случаях это вполне допустимо. Однако, как правило, в этом нет необходимости, так как это может привести к потере информации о причине ошибки: большинство операций могут завершиться с ошибкой по разным причинам.)

Для того, чтобы игнорировать исключение, установленное в результате вызова функции, которая завершилась с ошибкой, условие исключения должно быть явно очищено с помощью вызова [PyErr_Clear()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear). C-код должен вызывать [PyErr_Clear()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear) только в том случае, если он хочет обработать ошибку самостоятельно (например, попробовав что-то другое или сделав вид, что ничего не случилось), а не передавать её интерпретатору.

Каждый неудачный вызов <span style="font-family: Consolas, sans-serif;">malloc()</span> должен превращаться в исключение — прямой вызывающий <span style="font-family: Consolas, sans-serif;">malloc()</span> (или <span style="font-family: Consolas, sans-serif;">realloc()</span>) должен вызвать [PyErr_NoMemory()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_NoMemory) и сам вернуть индикатор ошибки. Все функции создания объектов (например, [PyLong_FromLong()](https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong)) уже делают это, поэтому это замечание актуально только для тех, кто вызывает malloc() напрямую.

Также стоит отметить, что, за исключением таких функций, как [PyArg_ParseTuple()](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple) и её аналогов, функции, возвращающие целочисленный статус, обычно возвращают положительное значение или ноль в случае успеха и `-1` в случае ошибки, как это происходит в системных вызовах Unix.

Будьте осторожны при очистке мусора (вызывайте [Py_XDECREF()](https://docs.python.org/3/c-api/refcounting.html#c.Py_XDECREF) или [Py_DECREF()](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF) для объектов, которые вы уже создали), когда возвращаете индикатор ошибки!

Выбор того, какое исключение вызвать, полностью зависит от вас. Существуют заранее определённые C-объекты, соответствующие всем встроенным исключениям Python, такие как <span style="font-family: Consolas, sans-serif;">PyExc_ZeroDivisionError</span>, которые вы можете использовать напрямую. Конечно, вам следует разумно выбирать исключения — не используйте <span style="font-family: Consolas, sans-serif;">PyExc_TypeError</span> для того, чтобы указать, что файл не удалось открыть (для этого лучше подойдёт <span style="font-family: Consolas, sans-serif;">PyExc_OSError</span>). Если что-то не так с аргументами, функция [PyArg_ParseTuple()](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple) обычно вызывает <span style="font-family: Consolas, sans-serif;">PyExc_TypeError</span>. Если у вас есть аргумент, чье значение должно быть в определённом диапазоне или удовлетворять другим условиям, то <span style="font-family: Consolas, sans-serif;">PyExc_ValueError</span> будет подходящим выбором.

Вы также можете определить новое исключение, уникальное для вашего модуля. Для этого обычно объявляют статическую переменную объекта в начале файла:

```c
static PyObject *SpamError;
```

и инициализируют её в функции инициализации модуля (<span style="font-family: Consolas, sans-serif;">PyInit_spam()</span>) с объектом исключения:

```c
PyMODINIT_FUNC
PyInit_spam(void)
{
    PyObject *m;

    m = PyModule_Create(&spammodule);
    if (m == NULL)
        return NULL;

    SpamError = PyErr_NewException("spam.error", NULL, NULL);
    if (PyModule_AddObjectRef(m, "error", SpamError) < 0) {
        Py_CLEAR(SpamError);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
```

Обратите внимание, что имя этого исключения в Python — <span style="font-family: Consolas, sans-serif;">spam.error</span>. Функция [PyErr_NewException()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_NewException) может создать класс, унаследованный от класса [Exception](https://docs.python.org/3/library/exceptions.html#Exception) (если вместо `NULL` не передан другой класс), который описан в разделе [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#bltin-exceptions).

Также стоит отметить, что переменная <span style="font-family: Consolas, sans-serif;">SpamError</span> сохраняет ссылку на только что созданный класс исключения; это сделано намеренно! Поскольку исключение может быть удалено из модуля внешним кодом, необходима собственная ссылка на класс, чтобы гарантировать, что он не будет удалён, что может привести к тому, что <span style="font-family: Consolas, sans-serif;">SpamError</span> станет висячим указателем. Если это произойдёт, C-код, вызывающий это исключение, может вызвать аварийное завершение программы (core dump) или другие непредвиденные побочные эффекты.

Мы обсудим использование [PyMODINIT_FUNC](https://docs.python.org/3/c-api/intro.html#c.PyMODINIT_FUNC) в качестве типа возвращаемого значения функции позже в этом примере.

Исключение <span style="font-family: Consolas, sans-serif;">spam.error</span> может быть вызвано в вашем расширении с помощью вызова [PyErr_SetString()](https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetString), как показано ниже:

```c
static PyObject *
spam_system(PyObject *self, PyObject *args)
{
    const char *command;
    int sts;

    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;
    sts = system(command);
    if (sts < 0) {
        PyErr_SetString(SpamError, "System command failed");
        return NULL;
    }
    return PyLong_FromLong(sts);
}
```

## 1.3. Возвращение к примеру
Текст для подраздела 1.1.

## 1.4. Таблица методов модуля и функция инициализации
Текст для подраздела 1.1.

## 1.5. Компиляция и компоновка
Текст для подраздела 1.1.

## 1.6. Вызов функций Python из C
Текст для подраздела 1.1.

## 1.7. Извлечение параметров в функциях расширения
Текст для подраздела 1.1.

## 1.8. Ключевые параметры для функций расширения
Текст для подраздела 1.1.

## 1.9. Создание произвольных значений
Текст для подраздела 1.1.

## 1.10. Учёт ссылок (Reference Counts)
Текст для подраздела 1.1.

## 1.11. Написание расширений на C++
Текст для подраздела 1.1.

## 1.12. Предоставление C API для модуля расширения
Текст для подраздела 1.1.

# 2. Определение типов расширений: учебное пособие
Текст для раздела 1.

## 2.1. Основы
Текст для подраздела 1.1.

## 2.2. Добавление данных и методов к базовому примеру
Текст для подраздела 1.1.

## 2.3. Более точный контроль над атрибутами данных
Текст для подраздела 1.1.

## 2.4. Поддержка циклического сборщика мусора
Текст для подраздела 1.1.

## 2.5. Наследование от других типов
Текст для подраздела 1.1.

# 3. Определение типов расширений: различные темы
Текст для раздела 1.

## 3.1. Завершение и освобождение памяти
Текст для подраздела 1.1.

## 3.2. Представление объекта
Текст для подраздела 1.1.

## 3.3. Управление атрибутами
Текст для подраздела 1.1.

## 3.4. Сравнение объектов
Текст для подраздела 1.1.

## 3.5. Поддержка абстрактных протоколов
Текст для подраздела 1.1.

## 3.6. Поддержка слабых ссылок
Текст для подраздела 1.1.

## 3.7. Дополнительные рекомендации
Текст для подраздела 1.1.

# 4. Сборка расширений на C и C++
Текст для раздела 1.

## 4.1. Сборка расширений на C и C++ с помощью setuptools
Текст для подраздела 1.1.

# 5. Сборка расширений на C и C++ в Windows
Текст для раздела 1.

## 5.1. Пошаговое руководство
Текст для раздела 1.

## 5.2. Различия между Unix и Windows
Текст для раздела 1.

## 5.3. Использование DLL на практике
Текст для раздела 1.

## Встраивание среды выполнения CPython в более крупное приложение
Иногда вместо создания расширения, которое выполняется внутри интерпретатора Python как основное приложение, бывает полезно встроить среду выполнения CPython в более крупное приложение. В этом разделе рассматриваются основные аспекты успешной интеграции CPython в такие приложения.

# 1. Встраивание Python в другое приложение

## 1.1. Встраивание на очень высоком уровне
Текст для подраздела 1.1.

## 1.2. За пределами встраивания на очень высоком уровне: обзор
Текст для подраздела 1.1.

## 1.3. Чистое встраивание
Текст для подраздела 1.1.

## 1.4. Расширение встроенного Python
Текст для подраздела 1.1.

## 1.5. Встраивание Python в C++
Текст для подраздела 1.1.

## 1.6. Компиляция и компоновка в Unix-подобных системах
Текст для подраздела 1.1.

**Сноски**

<a id="footnote-1"></a>[[1](#footnote-1-back)] Интерфейс для этой функции уже существует в стандартном модуле [os](https://docs.python.org/3/library/os.html#module-os) — он был выбран в качестве простого и наглядного примера.